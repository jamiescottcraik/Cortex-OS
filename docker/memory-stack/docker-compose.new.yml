version: "3.9"

x-health: &curl-health
  test: ["CMD", "sh", "-c", "curl -fsS $$HEALTH_URL || exit 1"]
  interval: 10s
  timeout: 2s
  retries: 5
  start_period: 10s

networks:
  mcp_net:

volumes:
  memories_data:

services:
  qdrant:
    image: qdrant/qdrant:latest
    restart: unless-stopped
    networks: [mcp_net]
    ports:
      - "6333:6333"             # local dev
    environment:
      - QDRANT__SERVICE__GRPC_PORT=6334
      - HEALTH_URL=http://localhost:6333/collections
    healthcheck:
      <<: *curl-health

  # Local-Memory service (REST) – acts as Memory-Core API
  local-memory:
    build:
      context: ../..
      dockerfile: packages/memory-rest-api/Dockerfile
    image: cortex/local-memory:dev
    depends_on:
      qdrant:
        condition: service_healthy
    restart: unless-stopped
    networks: [mcp_net]
    ports:
      - "3028:3028"             # REST Memory API (dev)
    environment:
      - MEMORY_DB_PATH=/data/unified-memories.db
      - QDRANT_URL=http://qdrant:6333
      - QDRANT_COLLECTION=local_memory_v1
      - EMBEDDING_MODEL=bge-small-en-v1.5
      - EMBED_DIM=384
      - NODE_ENV=production
      - MEMORY_LOG_LEVEL=info
      - MEMORY_DEFAULT_LIMIT=10
      - MEMORY_MAX_LIMIT=100
      - MEMORY_DEFAULT_THRESHOLD=0.5
      - MEMORY_HYBRID_WEIGHT=0.6
      - HEALTH_URL=http://localhost:3028/healthz
    volumes:
      - memories_data:/data
    healthcheck:
      <<: *curl-health

  # MCP hub (stdio + http/streamable), registers memory.* and agent_toolkit_*
  cortex-mcp:
    build:
      context: ../..
      dockerfile: packages/mcp-server/Dockerfile
    image: cortex/mcp-hub:dev
    depends_on:
      local-memory:
        condition: service_healthy
    restart: unless-stopped
    networks: [mcp_net]
    ports:
      - "9600:9600"             # MCP HTTP/streamable for remote clients
    environment:
      # Memory provider env (the hub calls memory-core directly)
      - MEMORY_DB_PATH=/data/unified-memories.db
      - QDRANT_URL=http://qdrant:6333
      - QDRANT_COLLECTION=local_memory_v1
      - EMBED_DIM=384
      # Agent-toolkit resolution (host mount below)
      - CORTEX_HOME=/opt/cortex-home
      - AGENT_TOOLKIT_TOOLS_DIR=/opt/cortex-home/tools/agent-toolkit
      - NODE_ENV=production
      - MEMORY_LOG_LEVEL=info
      - LOG_FORMAT=json
      - HEALTH_URL=http://localhost:9600/healthz
    volumes:
      - memories_data:/data
      # Bind your host toolkit directory into the container
      - /Users/jamiecraik/.Cortex-OS:/opt/cortex-home:ro
    healthcheck:
      <<: *curl-health

  # (Optional) REST façade – only if you keep a separate thin API
  # You can drop this if local-memory already is your REST API.
  rest-api:
    build:
      context: ../..
      dockerfile: packages/memory-rest-api/Dockerfile
    image: cortex/rest-api:dev
    depends_on:
      cortex-mcp:
        condition: service_healthy
    restart: unless-stopped
    networks: [mcp_net]
    ports:
      - "9700:9700"
    environment:
      - PORT=9700
      - MEMORY_DB_PATH=/data/unified-memories.db
      - QDRANT_URL=http://qdrant:6333
      - QDRANT_COLLECTION=local_memory_v1
      - MEMORY_LOG_LEVEL=info
      - HEALTH_URL=http://localhost:9700/healthz
    volumes:
      - memories_data:/data
    healthcheck:
      <<: *curl-health

  # (Optional) reverse proxy for remote MCP (TLS)
  # Enable only if you want to expose cortex-mcp:9600 publicly.
  # proxy:
  #   image: caddy:alpine
  #   depends_on:
  #     cortex-mcp:
  #       condition: service_healthy
  #   restart: unless-stopped
  #   networks: [mcp_net]
  #   ports:
  #     - "443:443"
  #     - "80:80"
  #   volumes:
  #     - ./caddy/Caddyfile:/etc/caddy/Caddyfile:ro