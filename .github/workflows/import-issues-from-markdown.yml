name: Import Issues from Markdown

on:
  workflow_dispatch:
    inputs:
      globs:
        description: "Comma-separated globs to scan for issue markdown files"
        required: false
        default: "legal-notifications/github-issue-*.md,scripts/config/.github/issues/*.md,issue*.md"
  push:
    paths:
      - "legal-notifications/github-issue-*.md"
      - "scripts/config/.github/issues/*.md"

permissions:
  contents: write
  issues: write

jobs:
  import:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Resolve candidate files
        id: files
        shell: bash
        run: |
          set -euo pipefail
          echo "Resolving files..."

          files=()

          if [[ "${{ github.event_name }}" == "push" ]]; then
            before="${{ github.event.before }}"
            after="${{ github.sha }}"
            # Write changed markdown files and ignore non-matches gracefully
            git diff --name-only "$before" "$after" | grep -E '\\.(md|markdown)$' > changed.txt || true
            while IFS= read -r f; do
              case "$f" in
                legal-notifications/github-issue-*.md|scripts/config/.github/issues/*.md)
                  files+=("$f")
                  ;;
              esac
            done < changed.txt
          else
            IFS=',' read -ra GLOBS <<< "${{ inputs.globs }}"
            for g in "${GLOBS[@]}"; do
              shopt -s nullglob
              for f in $g; do
                [[ -f "$f" ]] && files+=("$f") || true
              done
              shopt -u nullglob
            done
          fi

          # Deduplicate
          mapfile -t unique < <(printf '%s\n' "${files[@]:-}" | awk 'NF' | sort -u)
          count=${#unique[@]}
          echo "Found $count candidate file(s)."

          printf '%s\n' "${unique[@]:-}" > candidate_files.txt
          {
            echo "count=$count"
            echo 'list<<EOF'
            cat candidate_files.txt
            echo 'EOF'
          } >> "$GITHUB_OUTPUT"

      - name: Create GitHub issues from files
        id: create_issues
        if: steps.files.outputs.count != '0'
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs');
            const path = require('path');

            function parseFrontmatter(content) {
              const fm = { title: null, labels: [], assignees: [] };
              if (content.startsWith('---')) {
                const end = content.indexOf('\n---', 3);
                if (end !== -1) {
                  const raw = content.slice(3, end).trim();
                  const titleMatch = raw.match(/\btitle\s*:\s*["']([^"']+)["']/i);
                  if (titleMatch) fm.title = titleMatch[1].trim();
                  const labelsMatch = raw.match(/\blabels\s*:\s*\[([^\]]*)\]/i);
                  if (labelsMatch) fm.labels = labelsMatch[1].split(',').map(s => s.replace(/["'\s]/g, '')).filter(Boolean);
                  const assigneesMatch = raw.match(/\bassignees\s*:\s*\[([^\]]*)\]/i);
                  if (assigneesMatch) fm.assignees = assigneesMatch[1].split(',').map(s => s.replace(/["'\s]/g, '')).filter(Boolean);
                  const body = content.slice(end + '\n---'.length).replace(/^\n+/, '');
                  return { ...fm, body };
                }
              }
              return { ...fm, body: content };
            }

            function deriveTitleFromBody(body, fallback) {
              const m = body.match(/^#\s+(.+)$/m);
              return m ? m[1].trim() : fallback;
            }

            async function findOpenIssueByTitle(title) {
              const q = `repo:${context.repo.owner}/${context.repo.repo} is:issue state:open in:title "${title.replace(/"/g, '\\"')}"`;
              const res = await github.rest.search.issuesAndPullRequests({ q });
              return res.data.items.find(it => it.title === title && it.state === 'open');
            }

            async function createIssue({ title, body, labels, assignees }) {
              try {
                const res = await github.rest.issues.create({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  title,
                  body,
                  labels: labels && labels.length ? labels : undefined,
                  assignees: assignees && assignees.length ? assignees : undefined,
                });
                core.info(`Created issue #${res.data.number} - ${title}`);
                return res.data;
              } catch (err) {
                core.warning(`Create with labels/assignees failed for '${title}': ${err.message}. Retrying minimal...`);
                const res = await github.rest.issues.create({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  title,
                  body,
                });
                core.info(`Created issue #${res.data.number} - ${title}`);
                return res.data;
              }
            }

            const created = [];
            const list = `${process.env.LIST_FROM_OUTPUT || ''}`.split('\n').map(s => s.trim()).filter(Boolean);
            for (const rel of list) {
              const p = path.join(process.env.GITHUB_WORKSPACE || process.cwd(), rel);
              if (!fs.existsSync(p)) { core.warning(`Missing file: ${rel}`); continue; }
              const raw = fs.readFileSync(p, 'utf8');
              const { title: fmTitle, labels, assignees, body } = parseFrontmatter(raw);
              const title = fmTitle || deriveTitleFromBody(body, path.basename(rel));

              const existing = await findOpenIssueByTitle(title);
              if (existing) { core.info(`Issue exists (#${existing.number}) for '${title}', skipping.`); continue; }

              await createIssue({ title, body, labels, assignees });
              created.push(rel);
            }
            // Persist created files list for downstream steps
            try {
              const outPath = path.join(process.env.GITHUB_WORKSPACE || process.cwd(), 'created_files.txt');
              require('fs').writeFileSync(outPath, created.join('\n'));
              core.info(`Wrote created files list to ${outPath}`);
            } catch (e) {
              core.warning(`Failed to write created files list: ${e.message}`);
            }
        env:
          LIST_FROM_OUTPUT: ${{ steps.files.outputs.list }}

      - name: Archive processed markdown files
        if: steps.files.outputs.count != '0'
        id: archive
        shell: bash
        run: |
          set -euo pipefail
          echo "Archiving created markdown files..."
          if [[ ! -s created_files.txt ]]; then
            echo "No created issue files to archive. Skipping."
            exit 0
          fi
          cp created_files.txt created.txt
          while IFS= read -r f; do
            dir=$(dirname "$f")
            base=$(basename "$f")
            archive_dir="$dir/archive"
            mkdir -p "$archive_dir"
            # Use git mv when possible; fallback to mv + git add
            if git ls-files --error-unmatch -- "$f" > /dev/null 2>&1; then
              git mv -k -- "$f" "$archive_dir/" || { mv -- "$f" "$archive_dir/"; git add -- "$archive_dir/$base"; git rm -f --cached -- "$f" || true; }
            else
              mv -- "$f" "$archive_dir/"
              git add -- "$archive_dir/$base"
            fi
          done < created.txt

          if ! git diff --cached --quiet; then
            git config user.name "github-actions[bot]"
            git config user.email "41898282+github-actions[bot]@users.noreply.github.com"
            git commit -m "chore(issues): archive imported issue markdown files [skip ci]"
            git push
            echo "Archived files committed and pushed."
          else
            echo "No changes to commit."
          fi

      - name: No candidates found
        if: steps.files.outputs.count == '0'
        run: echo "No issue markdown files found to process."
