---
title: Examples
sidebar_label: Examples
---

# Examples & Tutorials

## Ingest and Search with MLX
See `examples/memories-mlx/ingest-and-search.ts` for a script that indexes files and queries them using the MLX embedder.

## Web Service Integration
A minimal Express integration:
```typescript
import express from 'express';
import { createMemoryService, createEmbedderFromEnv, createPolicyAwareStoreFromEnv } from '@cortex-os/memories';
const app = express();
const svc = createMemoryService(createPolicyAwareStoreFromEnv(), createEmbedderFromEnv());
app.post('/remember', async (req, res) => {
  await svc.upsert({ id: req.body.id, text: req.body.text });
  res.sendStatus(204);
});
```

## Direct MCP Tool Invocation
Quickly exercise a tool without spinning up a server by calling its handler directly and parsing the envelope returned in `content[0].text`:
```typescript
import { memoryStoreTool } from '@cortex-os/memories';

const response = await memoryStoreTool.handler({
  kind: 'note',
  text: 'Initial design summary',
  tags: ['architecture', 'v1']
});

const payload = JSON.parse(response.content[0]?.text ?? '{}');
if (payload.success) {
  console.log('Stored memory preview:', payload.data.redactedPreview);
} else {
  console.error('Tool failure:', payload.error.code, payload.error.details);
}
```
Use the same pattern with `memoryRetrieveTool`, `memoryUpdateTool`, and the other exports to validate schema behaviour before wiring the tools into a transport.

## Register Memory MCP Tools with the MCP SDK
Expose all contract-checked tools through the official MCP server by iterating over `memoryMcpTools`:
```typescript
import { memoryMcpTools } from '@cortex-os/memories';
import { Server } from '@modelcontextprotocol/sdk/server/index.js';
import { StdioServerTransport } from '@modelcontextprotocol/sdk/server/stdio.js';

const server = new Server({ name: 'memories', version: '0.1.0' });

for (const tool of memoryMcpTools) {
  server.tool(
    tool.name,
    tool.description,
    tool.inputSchema,
    async (input) => tool.handler(input)
  );
}

await server.connect(new StdioServerTransport());
```
This keeps the built-in sanitisation, correlation IDs, and structured errors defined in `src/mcp/tools.ts` while letting the SDK handle transportsâ€”swap `StdioServerTransport` for HTTP/SSE/WebSocket variants as needed.

## Smoke Test Memory Tools with @cortex-os/mcp-core
Combine the packaged mock server and client to execute the contract end-to-end over HTTP without bespoke infrastructure:
```typescript
import { createEnhancedClient } from '@cortex-os/mcp-core';
import { MockMCPServer } from '@cortex-os/mcp-core/testing';
import { memoryStoreTool } from '@cortex-os/memories';

const server = await MockMCPServer.create();
server.registerTool(memoryStoreTool.name, memoryStoreTool.handler);

const client = await createEnhancedClient({
  name: 'memories-mock',
  transport: 'http',
  endpoint: server.endpoint,
});

const result = await client.callTool({
  name: memoryStoreTool.name,
  arguments: { kind: 'note', text: 'contract smoke test' },
});

console.dir(result, { depth: null });
await client.close();
await server.stop();
```
The mock server preserves the same JSON payload shape generated by the real handlers, so any validation failures (for example, exceeding the 8,192 character limit) surface through the `error.details` array just as they would in production.
