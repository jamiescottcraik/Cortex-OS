nContext,\n\t): ValidationResult {\n\t\treturn {\n\t\t\tapproved: false,\n\t\t\treason: 'TDD state unclear - please start with a failing test',\n\t\t\tsuggestion:\n\t\t\t\t'Write a test that fails for the feature you want to implement',\n\t\t};\n\t}\n\n\t// Helper methods\n\tprivate validateMinimalChange(\n\t\tchange: ChangeSet,\n\t\t_failingTests: TestResult[],\n\t): boolean {\n\t\t// Implementation: Check if change is minimal relative to failing tests\n\t\t// This would analyze code coverage and change scope\n\t\treturn change.totalChanges < 50; // Simplified for now\n\t}\n\n\tprivate isRefactorOnly(change: ChangeSet): boolean {\n\t\t// Implementation: Analyze if changes are purely structural\n\t\t// Look for patterns like variable renames, method extractions, etc.\n\t\treturn !change.files.some((f) => f.linesAdded > f.linesDeleted * 1.2);\n\t}\n\n\tprivate detectNewTest(change: ChangeSet): boolean {\n\t\treturn change.files.some(\n\t\t\t(f) =>\n\t\t\t\t(this.isTestFile(f.path) && f.status === 'added') ||\n\t\t\t\t(f.status === 'modified' && f.linesAdded > 0),\n\t\t);\n\t}\n\n\tprivate detectNewFunctionality(change: ChangeSet): boolean {\n\t\treturn change.files.some(\n\t\t\t(f) => !this.isTestFile(f.path) && f.linesAdded > 0,\n\t\t);\n\t}\n\n\tprivate isTestFile(path: string): boolean {\n\t\treturn (\n\t\t\t/\\.(test|spec)\\.(ts|js|py|rs)$/.test(path) ||\n\t\t\t/test_.*\\.py$/.test(path) ||\n\t\t\t/.*_test\\.(go|rs)$/.test(path)\n\t\t);\n\t}\n\n\tprivate checkMinimality(\n\t\tchange: ChangeSet,\n\t\t_failingTests: TestResult[],\n\t): {\n\t\tisMinimal: boolean;\n\t\tsuggestion: string;\n\t\texcessLines?: string[];\n\t} {\n\t\t// Simplified minimality check\n\t\tif (change.totalChanges > 100) {\n\t\t\treturn {\n\t\t\t\tisMinimal: false,\n\t\t\t\tsuggestion:\n\t\t\t\t\t'Break this into smaller changes - make one test pass at a time',\n\t\t\t\texcessLines: change.files\n\t\t\t\t\t.filter((f) => f.linesAdded > 20)\n\t\t\t\t\t.map((f) => f.path),\n\t\t\t};\n\t\t}\n\n\t\treturn {\n\t\t\tisMinimal: true,\n\t\t\tsuggestion: 'Change looks appropriately minimal',\n\t\t};\n\t}\n\n\t// State management methods\n\tasync unlockImplementationFiles(files: string[]): Promise<void> {\n\t\t// Implementation: Grant write permissions to specific files\n\t\tconsole.log(`Unlocking implementation files: ${files.join(', ')}`);\n\t}\n\n\tasync enableRefactorMode(): Promise<void> {\n\t\t// Implementation: Enable broader file access for refactoring\n\t\tconsole.log(\n\t\t\t'Enabling refactor mode - all files unlocked for structural changes',\n\t\t);\n\t}\n\n\tasync lockImplementationFiles(): Promise<void> {\n\t\t// Implementation: Restrict write access to test files only\n\t\tconsole.log('Locking implementation files - test-only mode active');\n\t}\n\n\tasync initiateTDDCycle(): Promise<void> {\n\t\t// Implementation: Set up new TDD cycle\n\t\tconsole.log('Initiating new TDD cycle');\n\t}\n\n\tprivate logTransition(message: string): void {\n\t\tconsole.log(`[TDD State Machine] ${message}`);\n\t}\n\n\t// Public getters\n\tgetCurrentState(): TDDStateData {\n\t\treturn { ...this.stateData };\n\t}\n\n\tgetStateHistory(): string[] {\n\t\t// Implementation: Return state transition history\n\t\treturn [];\n\t}\n}\n","usedDeprecatedRules":[]},{"filePath":"/Users/jamiecraik/.Cortex-OS/packages/tdd-coach/src/index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/jamiecraik/.Cortex-OS/packages/tdd-coach/src/reporters/BaseTestReporter.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/jamiecraik/.Cortex-OS/packages/tdd-coach/src/reporters/LanguageReporters.ts","messages":[{"ruleId":"sonarjs/no-nested-conditional","severity":1,"message":"Extract this nested ternary operation into an independent statement.","line":69,"column":11,"nodeType":"ConditionalExpression","messageId":"extractTernary","endLine":71,"endColumn":18},{"ruleId":"sonarjs/slow-regex","severity":1,"message":"Make sure the regex used here, which is vulnerable to super-linear runtime due to backtracking, cannot lead to denial of service.","line":130,"column":54,"nodeType":"Literal","endLine":130,"endColumn":60},{"ruleId":"sonarjs/no-nested-conditional","severity":1,"message":"Extract this nested ternary operation into an independent statement.","line":253,"column":13,"nodeType":"ConditionalExpression","messageId":"extractTernary","endLine":255,"endColumn":20}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import * as fs from 'node:fs';\nimport type { TestResult } from '../types/TDDTypes.js';\nimport { BaseTestReporter } from './BaseTestReporter.js';\n\nexport class PytestReporter extends BaseTestReporter {\n\tname = 'pytest';\n\tlanguage = 'python';\n\n\tdetectsTestFiles(filePath: string): boolean {\n\t\treturn (\n\t\t\t/test_.*\\.py$/.test(filePath) ||\n\t\t\t/_test\\.py$/.test(filePath) ||\n\t\t\tfilePath.includes('test_') ||\n\t\t\tfilePath.includes('conftest.py')\n\t\t);\n\t}\n\n\tasync runTests(filePaths?: string[]): Promise<TestResult[]> {\n\t\t// Check if we're in mock mode (for testing) to avoid spawning real processes\n\t\tif (process.env.NODE_ENV === 'test' || this.config.mockMode) {\n\t\t\treturn this.createMockPytestResults(filePaths);\n\t\t}\n\n\t\tconst args = [\n\t\t\t'--json-report',\n\t\t\t'--json-report-file=/tmp/pytest-report.json',\n\t\t];\n\n\t\tif (filePaths && filePaths.length > 0) {\n\t\t\targs.push(...filePaths);\n\t\t}\n\n\t\tif (this.config.coverage) {\n\t\t\targs.push('--cov');\n\t\t}\n\n\t\ttry {\n\t\t\tawait this.executeCommand('python', ['-m', 'pytest', ...args]);\n\n\t\t\t// Read the JSON report file\n\t\t\tconst reportPath = '/tmp/pytest-report.json';\n\n\t\t\tif (fs.existsSync(reportPath)) {\n\t\t\t\tconst reportData = fs.readFileSync(reportPath, 'utf8');\n\t\t\t\treturn this.parsePytestOutput(reportData);\n\t\t\t}\n\n\t\t\treturn [];\n\t\t} catch (error) {\n\t\t\tconsole.error('Pytest execution failed:', error);\n\t\t\treturn [];\n\t\t}\n\t}\n\n\tprivate parsePytestOutput(output: string): TestResult[] {\n\t\tconst results: TestResult[] = [];\n\n\t\ttry {\n\t\t\tconst data = JSON.parse(output);\n\n\t\t\tif (data.tests) {\n\t\t\t\tfor (const test of data.tests) {\n\t\t\t\t\tresults.push({\n\t\t\t\t\t\tid: test.nodeid,\n\t\t\t\t\t\tname: test.test || test.nodeid.split('::').pop() || 'unknown',\n\t\t\t\t\t\tstatus:\n\t\t\t\t\t\t\ttest.outcome === 'passed'\n\t\t\t\t\t\t\t\t? 'pass'\n\t\t\t\t\t\t\t\t: test.outcome === 'failed'\n\t\t\t\t\t\t\t\t\t? 'fail'\n\t\t\t\t\t\t\t\t\t: 'skip',\n\t\t\t\t\t\tduration: test.duration || 0,\n\t\t\t\t\t\tfile: test.file || 'unknown',\n\t\t\t\t\t\tline: test.lineno,\n\t\t\t\t\t\terror:\n\t\t\t\t\t\t\ttest.call?.longrepr ||\n\t\t\t\t\t\t\ttest.setup?.longrepr ||\n\t\t\t\t\t\t\ttest.teardown?.longrepr,\n\t\t\t\t\t\tstack: test.call?.traceback?.join('\\n') || undefined,\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (error) {\n\t\t\tconsole.warn('Failed to parse pytest output:', error);\n\t\t}\n\n\t\treturn results;\n\t}\n\n\tprivate createMockPytestResults(filePaths?: string[]): TestResult[] {\n\t\t// Create mock test results for testing purposes\n\t\treturn [\n\t\t\t{\n\t\t\t\tid: 'test_mock.py::test_example',\n\t\t\t\tname: 'test_example',\n\t\t\t\tstatus: 'pass',\n\t\t\t\tduration: 25,\n\t\t\t\tfile: filePaths?.[0] || 'test_mock.py',\n\t\t\t\tline: 5,\n\t\t\t},\n\t\t];\n\t}\n}\n\nexport class RustTestReporter extends BaseTestReporter {\n\tname = 'rust-test';\n\tlanguage = 'rust';\n\n\tdetectsTestFiles(filePath: string): boolean {\n\t\treturn (\n\t\t\tfilePath.endsWith('.rs') &&\n\t\t\t(filePath.includes('test') ||\n\t\t\t\tfilePath.includes('lib.rs') ||\n\t\t\t\tfilePath.includes('main.rs'))\n\t\t);\n\t}\n\n\tasync runTests(filePaths?: string[]): Promise<TestResult[]> {\n\t\t// Check if we're in mock mode (for testing) to avoid spawning real processes\n\t\tif (process.env.NODE_ENV === 'test' || this.config.mockMode) {\n\t\t\treturn this.createMockRustResults(filePaths);\n\t\t}\n\n\t\tconst args = ['test', '--', '--format=json'];\n\n\t\tif (filePaths && filePaths.length > 0) {\n\t\t\t// Rust doesn't support running specific files easily\n\t\t\t// Filter would need to be done via test name patterns\n\t\t\tconst testNames = filePaths\n\t\t\t\t.map((path) => path.replace(/\\.rs$/, '').replace(/.*\\//, ''))\n\t\t\t\t.join('|');\n\t\t\targs.push(testNames);\n\t\t}\n\n\t\ttry {\n\t\t\tconst { stdout } = await this.executeCommand('cargo', args);\n\t\t\treturn this.parseRustTestOutput(stdout);\n\t\t} catch (error) {\n\t\t\tconsole.error('Rust test execution failed:', error);\n\t\t\treturn [];\n\t\t}\n\t}\n\n\tprivate createMockRustResults(filePaths?: string[]): TestResult[] {\n\t\t// Create mock test results for testing purposes\n\t\treturn [\n\t\t\t{\n\t\t\t\tid: 'test_mock.rs::test_example',\n\t\t\t\tname: 'test_example',\n\t\t\t\tstatus: 'pass',\n\t\t\t\tduration: 30,\n\t\t\t\tfile: filePaths?.[0] || 'test_mock.rs',\n\t\t\t\tline: 8,\n\t\t\t},\n\t\t];\n\t}\n\n\tprivate parseRustTestOutput(output: string): TestResult[] {\n\t\tconst results: TestResult[] = [];\n\n\t\ttry {\n\t\t\tconst lines = output.split('\\n').filter((line) => line.trim());\n\n\t\t\tfor (const line of lines) {\n\t\t\t\tif (line.startsWith('{')) {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tconst data = JSON.parse(line);\n\n\t\t\t\t\t\tif (data.type === 'test' && data.event === 'ok') {\n\t\t\t\t\t\t\tresults.push({\n\t\t\t\t\t\t\t\tid: data.name,\n\t\t\t\t\t\t\t\tname: data.name,\n\t\t\t\t\t\t\t\tstatus: 'pass',\n\t\t\t\t\t\t\t\tduration: data.exec_time || 0,\n\t\t\t\t\t\t\t\tfile: 'unknown', // Rust doesn't provide file info easily\n\t\t\t\t\t\t\t\tline: undefined,\n\t\t\t\t\t\t\t\terror: undefined,\n\t\t\t\t\t\t\t\tstack: undefined,\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t} else if (data.type === 'test' && data.event === 'failed') {\n\t\t\t\t\t\t\tresults.push({\n\t\t\t\t\t\t\t\tid: data.name,\n\t\t\t\t\t\t\t\tname: data.name,\n\t\t\t\t\t\t\t\tstatus: 'fail',\n\t\t\t\t\t\t\t\tduration: data.exec_time || 0,\n\t\t\t\t\t\t\t\tfile: 'unknown',\n\t\t\t\t\t\t\t\tline: undefined,\n\t\t\t\t\t\t\t\terror: data.stdout || 'Test failed',\n\t\t\t\t\t\t\t\tstack: undefined,\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t}\n\t\t\t\t\t} catch {\n\t\t\t\t\t\t// ignore JSON parse errors for individual lines\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (error) {\n\t\t\tconsole.warn('Failed to parse Rust test output:', error);\n\t\t}\n\n\t\treturn results;\n\t}\n}\n\nexport class JestReporter extends BaseTestReporter {\n\tname = 'jest';\n\tlanguage = 'javascript';\n\n\tdetectsTestFiles(filePath: string): boolean {\n\t\treturn (\n\t\t\t/\\.(test|spec)\\.(js|ts|jsx|tsx)$/.test(filePath) ||\n\t\t\tfilePath.includes('__tests__') ||\n\t\t\tfilePath.includes('jest.config.')\n\t\t);\n\t}\n\n\tasync runTests(filePaths?: string[]): Promise<TestResult[]> {\n\t\tconst args = ['test', '--json'];\n\n\t\tif (filePaths && filePaths.length > 0) {\n\t\t\targs.push(...filePaths);\n\t\t}\n\n\t\tif (this.config.coverage) {\n\t\t\targs.push('--coverage');\n\t\t}\n\n\t\ttry {\n\t\t\tconst { stdout } = await this.executeCommand('npm', ['run', ...args]);\n\t\t\treturn this.parseJestOutput(stdout);\n\t\t} catch (error) {\n\t\t\tconsole.error('Jest execution failed:', error);\n\t\t\treturn [];\n\t\t}\n\t}\n\n\tprivate parseJestOutput(output: string): TestResult[] {\n\t\tconst results: TestResult[] = [];\n\n\t\ttry {\n\t\t\tconst data = JSON.parse(output);\n\n\t\t\tif (data.testResults) {\n\t\t\t\tfor (const fileResult of data.testResults) {\n\t\t\t\t\tif (fileResult.assertionResults) {\n\t\t\t\t\t\tfor (const assertion of fileResult.assertionResults) {\n\t\t\t\t\t\t\tresults.push({\n\t\t\t\t\t\t\t\tid: `${fileResult.name}::${assertion.title}`,\n\t\t\t\t\t\t\t\tname: assertion.title,\n\t\t\t\t\t\t\t\tstatus:\n\t\t\t\t\t\t\t\t\tassertion.status === 'passed'\n\t\t\t\t\t\t\t\t\t\t? 'pass'\n\t\t\t\t\t\t\t\t\t\t: assertion.status === 'failed'\n\t\t\t\t\t\t\t\t\t\t\t? 'fail'\n\t\t\t\t\t\t\t\t\t\t\t: 'skip',\n\t\t\t\t\t\t\t\tduration: assertion.duration || 0,\n\t\t\t\t\t\t\t\tfile: fileResult.name,\n\t\t\t\t\t\t\t\tline: assertion.location?.line,\n\t\t\t\t\t\t\t\terror: assertion.failureMessages?.[0],\n\t\t\t\t\t\t\t\tstack: assertion.failureDetails?.[0]?.stack,\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (error) {\n\t\t\tconsole.warn('Failed to parse Jest output:', error);\n\t\t}\n\n\t\treturn results;\n\t}\n}\n\nexport class GoTestReporter extends BaseTestReporter {\n\tname = 'go-test';\n\tlanguage = 'go';\n\n\tdetectsTestFiles(filePath: string): boolean {\n\t\treturn /_test\\.go$/.test(filePath) || filePath.includes('test');\n\t}\n\n\tasync runTests(filePaths?: string[]): Promise<TestResult[]> {\n\t\tconst args = ['test', '-json'];\n\n\t\tif (filePaths && filePaths.length > 0) {\n\t\t\t// Go uses package paths, not file paths\n\t\t\tconst packages = [\n\t\t\t\t...new Set(\n\t\t\t\t\tfilePaths.map((path) => path.replace(/\\/[^/]*_test\\.go$/, '') || '.'),\n\t\t\t\t),\n\t\t\t];\n\t\t\targs.push(...packages);\n\t\t} else {\n\t\t\targs.push('./...');\n\t\t}\n\n\t\ttry {\n\t\t\tconst { stdout } = await this.executeCommand('go', args);\n\t\t\treturn this.parseGoTestOutput(stdout);\n\t\t} catch (error) {\n\t\t\tconsole.error('Go test execution failed:', error);\n\t\t\treturn [];\n\t\t}\n\t}\n\n\tprivate parseGoTestOutput(output: string): TestResult[] {\n\t\tconst results: TestResult[] = [];\n\n\t\ttry {\n\t\t\tconst lines = output.split('\\n').filter((line) => line.trim());\n\n\t\t\tfor (const line of lines) {\n\t\t\t\tif (line.startsWith('{')) {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tconst data = JSON.parse(line);\n\n\t\t\t\t\t\tif (data.Action === 'pass' || data.Action === 'fail') {\n\t\t\t\t\t\t\tresults.push({\n\t\t\t\t\t\t\t\tid: `${data.Package}::${data.Test}`,\n\t\t\t\t\t\t\t\tname: data.Test || 'unknown',\n\t\t\t\t\t\t\t\tstatus: data.Action === 'pass' ? 'pass' : 'fail',\n\t\t\t\t\t\t\t\tduration: data.Elapsed || 0,\n\t\t\t\t\t\t\t\tfile: data.Package || 'unknown',\n\t\t\t\t\t\t\t\tline: undefined,\n\t\t\t\t\t\t\t\terror: data.Output,\n\t\t\t\t\t\t\t\tstack: undefined,\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t}\n\t\t\t\t\t} catch {\n\t\t\t\t\t\t// ignore JSON parse errors for individual lines\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (error) {\n\t\t\tconsole.warn('Failed to parse Go test output:', error);\n\t\t}\n\n\t\treturn results;\n\t}\n}\n","usedDeprecatedRules":[]},{"filePath":"/Users/jamiecraik/.Cortex-OS/packages/tdd-coach/src/reporters/MockTestReporter.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'_filePath' is defined but never used.","line":16,"column":19,"nodeType":null,"messageId":"unusedVar","endLine":16,"endColumn":28},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'_filePaths' is defined but never used.","line":20,"column":17,"nodeType":null,"messageId":"unusedVar","endLine":20,"endColumn":27}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import type { TestResult } from '../types/TDDTypes.js';\nimport type { TestRunConfiguration } from './BaseTestReporter.js';\nimport { BaseTestReporter } from './BaseTestReporter.js';\n\nexport class MockTestReporter extends BaseTestReporter {\n\tname = 'mock';\n\tlanguage = 'mock';\n\tprivate mockResults: Map<string, TestResult[]> = new Map();\n\tprivate watchCallback?: (results: Map<string, TestResult[]>) => void;\n\n\tconstructor(config: TestRunConfiguration) {\n\t\tsuper(config);\n\t\tthis.setupMockData();\n\t}\n\n\tdetectsTestFiles(_filePath: string): boolean {\n\t\treturn true; // Mock reporter accepts all files\n\t}\n\n\tasync runTests(_filePaths?: string[]): Promise<TestResult[]> {\n\t\t// Simulate test execution delay\n\t\tawait this.delay(100);\n\n\t\tconst allResults: TestResult[] = [];\n\t\tfor (const [, results] of this.mockResults) {\n\t\t\tallResults.push(...results);\n\t\t}\n\t\treturn allResults;\n\t}\n\n\tasync runTestsForFile(filePath: string): Promise<TestResult[]> {\n\t\t// Simulate test execution delay\n\t\tawait this.delay(100);\n\n\t\treturn this.mockResults.get(filePath) || [];\n\t}\n\n\tasync runAllTests(): Promise<Map<string, TestResult[]>> {\n\t\t// Simulate test execution delay\n\t\tawait this.delay(200);\n\n\t\treturn new Map(this.mockResults);\n\t}\n\n\tasync startWatching(\n\t\tcallback: (results: Map<string, TestResult[]>) => void,\n\t): Promise<void> {\n\t\tthis.watchCallback = callback;\n\t\t// Simulate initial watch callback\n\t\tsetTimeout(() => {\n\t\t\tif (this.watchCallback) {\n\t\t\t\tthis.watchCallback(new Map(this.mockResults));\n\t\t\t}\n\t\t}, 50);\n\t}\n\n\tasync stopWatching(): Promise<void> {\n\t\tthis.watchCallback = undefined;\n\t}\n\n\tgetReporterInfo(): Array<{\n\t\tname: string;\n\t\tlanguage: string;\n\t\tavailable: boolean;\n\t}> {\n\t\treturn [\n\t\t\t{ name: 'mock-vitest', language: 'typescript', available: true },\n\t\t\t{ name: 'mock-pytest', language: 'python', available: true },\n\t\t\t{ name: 'mock-rust-test', language: 'rust', available: true },\n\t\t];\n\t}\n\n\t// Mock data setup\n\tprivate setupMockData(): void {\n\t\tthis.mockResults.set('src/example.test.ts', [\n\t\t\t{\n\t\t\t\tid: 'example-test-1',\n\t\t\t\tname: 'example test 1',\n\t\t\t\tstatus: 'pass',\n\t\t\t\tduration: 10,\n\t\t\t\tfile: 'src/example.test.ts',\n\t\t\t\tline: 5,\n\t\t\t},\n\t\t\t{\n\t\t\t\tid: 'example-test-2',\n\t\t\t\tname: 'example test 2',\n\t\t\t\tstatus: 'fail',\n\t\t\t\tduration: 15,\n\t\t\t\tfile: 'src/example.test.ts',\n\t\t\t\tline: 10,\n\t\t\t\terror: 'Expected true but got false',\n\t\t\t\tstack: 'at example.test.ts:10:5',\n\t\t\t},\n\t\t]);\n\n\t\tthis.mockResults.set('src/implementation.test.ts', [\n\t\t\t{\n\t\t\t\tid: 'implementation-test',\n\t\t\t\tname: 'implementation test',\n\t\t\t\tstatus: 'pass',\n\t\t\t\tduration: 8,\n\t\t\t\tfile: 'src/implementation.test.ts',\n\t\t\t\tline: 3,\n\t\t\t},\n\t\t]);\n\t}\n\n\t// Add mock test results for testing\n\taddMockTestResult(filePath: string, result: TestResult): void {\n\t\tif (!this.mockResults.has(filePath)) {\n\t\t\tthis.mockResults.set(filePath, []);\n\t\t}\n\t\tconst results = this.mockResults.get(filePath);\n\t\tif (results) {\n\t\t\tresults.push(result);\n\t\t}\n\t}\n\n\t// Clear mock results\n\tclearMockResults(): void {\n\t\tthis.mockResults.clear();\n\t}\n\n\t// Trigger watch callback manually for testing\n\ttriggerWatchCallback(): void {\n\t\tif (this.watchCallback) {\n\t\t\tthis.watchCallback(new Map(this.mockResults));\n\t\t}\n\t}\n\n\tprivate delay(ms: number): Promise<void> {\n\t\treturn new Promise((resolve) => setTimeout(resolve, ms));\n\t}\n}\n","usedDeprecatedRules":[]},{"filePath":"/Users/jamiecraik/.Cortex-OS/packages/tdd-coach/src/reporters/UniversalTestReporter.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/jamiecraik/.Cortex-OS/packages/tdd-coach/src/reporters/VitestReporter.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/jamiecraik/.Cortex-OS/packages/tdd-coach/src/types/TDDTypes.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/jamiecraik/.Cortex-OS/packages/tdd-coach/vitest.config.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]}]